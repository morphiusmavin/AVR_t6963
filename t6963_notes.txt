t6963_notes.txt

keypad layout:

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

Special character codes sent by the PIC24:

0xF5->0xFF - PIC24 is sending a sequence of predetermined bytes that are shifted, scaled or 
			bytes combined to make words and displayed at a list of predetermined 
			row,col locations
	RT_AUX		0xF5	- tells AVR to send a string of 20 bytes that was entered using the numentry/alnum dialog
	RT_TRIP		0xF6	- tells the AVR to expect 1 byte to be sent preceded by either RT_LOW or RT_HIGH0
	RT_TIME,	0xF7	-  "																		"
	RT_AIRT,	0xF8	-  "																		"
	RT_O2,		0xF9	-  "																		"
	RT_MAP,		0xFA	-  "																		"
	RT_OILT,	0xFB	-  "																		"
	RT_OILP,	0xFC	-  "																		"
	RT_ENGT,	0xFD	-  "																		"
	RT_MPH,		0xFE	-  "																		"
	RT_RPM		0xFF	- tells the AVR to expect 2 bytes to be send preceded by either RT_HIGH1/2/3
						- RT_HIGH1 - 2 bytes make up an unsigned int with neither MSB set
						- RT_HIGH2 - bit 7 of unsigned int is set
						- RT_HIGH3 - bit 15 of unsigned int is set

using this scheme allows the AVR to separate the RT_XXX commands from actual data						

bytes sent to represent keypresses
0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

When the PIC24 sends a byte in the range of 0xE0 -> 0xEF that will be interpreted as
a keypress. The dialog will filter this out using a switch statement. The default will
just return whatever was passed in. 

The beginning of eeprom stores all the labels used. Another table directly after the labels
stores the offsets from the beginning of eeprom to each label. Any part of the code that uses
the labels can just read them from eeprom as reading doesn't wear out the eeprom like writing
does. Reading out of eeprom is slower than reading from flash which is slower than ram, but
the code doesn't read the labels that often. 

Right after the above tables in eeprom there is an array of rt_params structs. 
typedef struct rt_params
{
	UINT label_offset;	// offset from beginning of eeprom
	UCHAR row;			// row, col tells where the param will appear on screen
	UCHAR col;	
	UCHAR shown;		// if its shown or not
	UCHAR type;			// 0 - UCHAR; 1 - UINT; 2 - string
} RT_PARAM;

The array of RT_PARAMS is read into an array in ram and can be changed by commands from
the PIC24 to re-arrange the display.

The next section of eeprom stores the default menu setup which is an array of the MENU_STRUCT:
typedef menu_struct
{
	UCHAR pnum;			// index
	UINT label_offset;	// offset into label section of eeprom of which label to use
	UCHAR row,			// row, col where the label will be displayed
	UCHAR col;
	UCHAR menu_choice;	// the type of keypress in the switch statement of the menu
	UCHAR type;			// index of which function pointer this menu label is associated with
} MENU_STRUCT;

This array will be read into program memory on startup and can be changed (added to ?) by
commands from the PIC24.
	
test_write_data:
The subdirectory call test_write_data has a separate makefile that compiles a program that I used
to test some of the functionality so I didn't have to keep reflashing the AVR. I used 2 linux boxes
connected with a crossed over serial cable. Run make, which will compile the test_write_data.c
using menus.c, t6963.c and USART.c from the main directory, the run copy.sh which will tar up the
files needed to compile the program on the other machines. You will have to edit the copy.sh script
to match your machine IP addresses. Then run the extract.sh script on your other 2 machines (I use
ssh to run the other 2 machines on my main box) and then run sudo ./test_write r (for the machine 
that simulates the the AVR) and sudo ./test_write w <interations*10> <starting rpm value> <other 
starting values> <time delay> to simulate the PIC24 or whatever processor is writing the data 
to the AVR.

TODO:

PIC24 sends commands that modify the RT_PARAM and MENU_STRUCT array to display params in different 
format on screen. It will also send commands to tell AVR to only display certain params. 
For instance. we may only want to see RPM, MPH and engine temp when a non-trivial dialog 
is on the screen. It can also send commands to modify a certain dialog, like different 
labels for checkboxes.

Each menu function that is pointed to by the array of function pointers 

The numentry/alnum dialog should primarily be used for entering a passcode to start the engine.
The AVR code will handle the password retries and timeouts. e.g. three tries to enter passcode and
passcode must be entered within 15 seconds or the system locks out totally for 1/2 hour.

Other parameters to have the system offer the user to change:
	- max rpm before rev-limiter kicks in (turn off ignition momentarily and flash warning light).
	- engine temperature too high and oil pressure too low level warning signals (lights and buzzer).
	- set outdoor temp at which block heater comes on. (when plugged into 110vac outlet)
	- set time of day and length of time other heaters come on.
	- set frequency of blinkers and how long to stay blinking (if not using the conventional switch)
	- how long for headlights to stay on after vehicle shuts off.

Use a generic menu function that has a switch statement where all the numbers call
cursor_forward_stuff(n); (where n is the number 0 - 9), '*' goes back to the previous menu 
and 'A','B','C','D' and '#' are assigned to do something by default. (display a 'not assigned' message).

typedef struct menu_func
{
	UCHAR enabled;		// if alt function will replace generic function
	UCHAR key;			// which keypress applies
	UCHAR fptr;			// which function to call (menu_types)
	UCHAR menu;			// if fptr == 0 then it means goto a this menu 
	UCHAR label;			// which label to display in legend (labels)
} MENU_FUNC_STRUCT;

Then have a table that assigns new functions to any of of these keypresses (or at least 'A'->'D',
'#' and '0') and the generic function will call a different function depending on what the 
table reassigned to it. 

keypad layout - since the six reassignable keys are on the outside (bottom and left) it makes
sense to use these as special function keys.
1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

First load from the eeprom the list of MENU_FUNC_STRUCT's which are in groups of 6 (6 possible
redefined keys for each menu choice) into an array. The 6 redefinable keys are
'A'
'B'
'C'
'D'
'#'
'0'
If the keypress has been reassigned, the 'enabled' field is set. That means the function for
the fptr (index into the list of function pointers) will be called. If the fptr is 0, then 
look up the menu specified by the menu element and just go to that menu. The function assigned 
to '*' in generic_menu_function() will always go back to the previous menu. 

This way, we have 3 possible choices:
1) Use the 'factory default' set of menus in eeprom.
2) Dynamically load another set of menus using a special command from the PIC24.
3) #2 plus burn the new menu set into eeprom.

Since we are trying to save ram space (which is the whole point of this exercise) then we
will just have 1 copy of a menu_func_struct in ram and reload the new one from eeprom
everytime we change menus.

last 3 checkins:
61ae87f did total revamp - works in test_data but menus not working yet
1e61ba3 separated do_read function into do_read.c
7e1a630 added scripts to remove trailing whitespace
