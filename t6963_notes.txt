t6963_notes.txt

keypad layout:

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

If the bottom left key '*' is pressed a menu will appear at the bottom for 5 seconds.
If any other key is not pressed within 5 seconds, the menu will go away. To do this,
use one of the AVR timers.

Depending on the keypress, we can send a special code to tell the PIC24's keypad 
routine to delay for so long after a keypress. Like when moving the cursor, the
delay between keypresses can be shorter so the cursor can move faster.

The menu at the bottom can be any number of rows. '*' will cancel the menu at anytime.
When the key that corrisponds to the menu is pressed, another menu or dialog will appear.
The most common dialog is one that lets the user enter a number. The menus will be 
handled by the main switch statement. Any dialogs will be handled by the special
functions (using function pointers).

One of the params for the number function can be the number of chars in the number dialog.
Another can be a number limit not to exceed.

Other dialogs can be ones that give the user a choice of on or off or a list of mutually-
exculsive options, like a group of checkboxes. There can also be a dialog that sets a
scale represented by a row of '*' or other characters. One key can move the scale to
the right (increase the value) or to the left (decrease). There will also be a dialog
to set the current time or the time value for something else.

The normal display will show the real-time values like engine rpm, mph, engine temp and
oil pressure. Later on, there can be different displays that show more or less real-time
parameters that can be changed by the menus. When the menu is active, any RT params on
the screen will continue to be displayed in real-time. They just won't over-write any-
thing on the menu area. So the menu or dialog will consume as little as possible area
at the bottom of the display. When 'Enter' or 'Cancel' is pressed the menu or dialog
will cause the previous menu to appear or the user can either hit the '*' key to make
the menu clear or the 'back' key to go back to the previous menu. 

Special character codes sent by the PIC24:

0xFF->0xF0 - PIC24 is sending a sequence of predetermined bytes that are shifted, scaled or 
			bytes combined to make words and displayed at a list of predetermined 
			row,col locations

Special characters sent by AVR to the PIC24:
0xFF - tells PIC24 to start sending a new predetermined sequence of values followed by param
0xFE -> 0xF0 - tells PIC24 to update a certain param followed by param # and value (1 or 2 bytes)
			the PIC24 can send that param to the TS-5500 if it applies.

bytes sent to represent keypresses
0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

When the PIC24 sends a byte in the range of 0xE0 -> 0xEF that will be interpreted as
a keypress. The dialog will filter this out using a switch statement. The default will
just return whatever was passed in. 

When the PIC24 sends a byte in the range of 0xF0 -> 0xFF that will be interpreted as
a special command to do something like hide the menu or update the display RT values.

The dispSetCursor function will set whatever row,col to a blinking cursor but
the dispCharAt function will display the char passed to it at its row,col parameters
regardless of where the blinking cursor is. When the a number is entered at the cursor
and/or the cursor is moved, the main loop will have to restore the current row,col used
by the RT display.

When the PIC24 sends a keypress it will reset the ESOS delay used by the task that is currently
sending data using the 0xFE command so that there won't be any overlapping of data. It can
also use semaphores to wait till the current sequence is finished before sending a keypress.

So the number enter dialog will use the '#' and the 'D' keys to move the cursor left or
right (resp). The any number key pressed will put the number in the space where the cursor
is. The current row,col used by the dialog is stored in the global variable cur_row, cur_col
and the number is in cur_global_number[10]. The dialog updates what's in new_global_number
and if the user cancels out, the new_global_number is reset. If the user hits 'Enter', the
cur_global_number is updated with new_global_number providing the new number is within
limits. 

Screen Layout:

typedef struct prompts
{
	uint8_t pnum;
	UCHAR row;
	UCHAR col;
    uint16_t offset;
	int len;
    uint8_t type;
} PROMPT_STRUCT;

eeprom_burn.c will record the initial 5 different types of screen layouts to eeprom and then
later on we can add a dialog which lets the user change the screen layout to suit.
RT_LAYOUT_STRUCT in RT_MAIN should be a pointer to a malloc'd list of RT_LAYOUT_STRUCT's.
num_params will be the number of params used. A function called update_layouts will fill the
ram space with all the RT_MAIN layouts and then all the RT_LAYOUT_STRUCT's. Then this function
will record it all to eeprom with the no_layouts next to no_prompts and prompt_info_offset at
0x03f4 in eeprom. (no_prompts is at 0x03f0 (byte) and prompt_info_offset is at 0x03f2 (word).

Special chars sent by PIC24:

The PIC24 sends a sequence of chars starting with one of the RT_TYPES. Each RT_TYPE is followed
by a DATA_TYPE which tells the AVR what kind of data to expect. All the data is sent as UCHAR
except for RT_RPM which is a UINT. If the data sent as a UCHAR is < 0x7f (127) the data type
will be RT_LOW. If the high bit is set (> 0x7f) the data type will be RT_HIGH0. If a UINT is 
set without the high bit for the first or second byte the data type will be RT_HIGH1. RT_HIGH2
has bit 7 set and RT_HIGH3 has bit 15 set. The AVR will then know by the data type sent just
after the RT_TYPE how to format the data (adding the appropriate high bit back in before printing
it to the screen. The reason for this is so it can filter out the keypresses (0xE0->0xEF).

enum rt_types
{
	RT_TRIP = 0xF6,
	RT_TIME,
	RT_AIRT,
	RT_OS,
	RT_MAP,
	RT_OILT,
	RT_OILP,
	RT_ENGT,
	RT_MPH,
	RT_RPM	// this should be 0xFF	
} RT_TYPES;

enum data_types
{
	RT_LOW,				// UCHAR without high bit set
	RT_HIGH0,			// UCHAR with bit 7 set
	RT_HIGH1,			// UINT with neither 7 or 15 set
	RT_HIGH2,			// bit 7 of UINT set
	RT_HIGH3			// bit 15 of UINT set
} DATA_TYPES;


enum menu_types
{
	MENU1,
	MENU2,
	MENU3,
	MENU4,
	MENU5,
	RT_LABEL
} MENU_TYPES;	

enum menu_order
{
	MAIN_MENU,
	MENU1A,
	MENU1B,
	MENU1C,
	MENU1D,
	MENU2A,
	MENU2B,
	MENU2C,
	MENU3A,
	MENU3B,
	MENU3C,
	MENU4A,
	MENU4B,
	MENU4C,
	NUM_ENTRY
} MENU_ORDER;


menus:

The menus are managed by function pointers. The default menu is main_menu_func. If the '*'
key is pressed the context will return to the previous menu. (the only exception to this
is the main menu).


UCHAR (*fptr[NUM_FPTS])(UCHAR, uint8_t, uint16_t, UCHAR, UCHAR) = { main_menu_func,\
	 menu1a, menu1b,\
	 menu1c, menu1d,\
	 menu2a, menu2b, menu2c,\
	 menu3a, menu3b, menu3c,\
	 menu4a, menu4b, menu4c, number_entry };

main_menu_func:
1) menu1a
	1) (go back)
	2) menu2a
	3) menu2b
	4) menu2c
2) menu1b
	1) main_menu_func (go back to top menu for now)
	2)	"    "    "                 "
	3)	"    "    "                 "
	4)	"    "    "                 "
3) menu1c
	1)	"    "    "                 "
	2)	"    "    "                 "
	3)	"    "    "                 "
	4)	"    "    "                 "
4) menu1d
	1)	"    "    "                 "
	2)	"    "    "                 "
	3)	"    "    "                 "
	4)	"    "    "                 "

menu2a:	
	1) number_entry
	2) main_menu_func (go back to top menu for now)
	3)	"    "    "                 "
	4)	"    "    "                 "
	
num_entry:
	enter keypad digits 0->9 - puts number in buffer
	A,B - enter, cancel
	(should present user with final number before enter

alpha_entry:
	enter alphanumeric 0x21->0x7e using a pull-down that lets user scroll thru list
	(or enter 0->9 and/or A->D)
	
params in TS-5500 that can be set:
	tasks: enable,delay,priority
	comm port settings
	change passcode
	Qtraffic: record to logfile, view errors only, etc
		Qtraffic: 
			int type;
			int error;
			UCHAR param;
			UCHAR onoff;
			INT32U OSTime;
			
	blinker time
	number of blinks
	rt params:
		engine temp warning
		engine temp shutdown
		oil pressure warning
		oil pressure shutdown
		battery temp on (for battery heater)
		battery temp off	"	"	"
		
checkbox group dialog:
	predefines set of on/off params to change where user can scroll cursor
	to checkboxes and set/unset

dialog for viewing TS-5500 Qtraffic logfiles
	view latest
	view range (date/time)
	reset/erase
	manage files on flash disk
				

