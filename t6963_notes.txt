t6963_notes.txt

keypad layout:

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

If the bottom left key '*' is pressed a menu will appear at the bottom for 5 seconds.
If any other key is not pressed within 5 seconds, the menu will go away. To do this,
use one of the AVR timers.

Depending on the keypress, we can send a special code to tell the PIC24's keypad 
routine to delay for so long after a keypress. Like when moving the cursor, the
delay between keypresses can be shorter so the cursor can move faster.

The menu at the bottom can be any number of rows. '*' will cancel the menu at anytime.
When the key that corrisponds to the menu is pressed, another menu or dialog will appear.
The most common dialog is one that lets the user enter a number. The menus will be 
handled by the main switch statement. Any dialogs will be handled by the special
functions (using function pointers).

One of the params for the number function can be the number of chars in the number dialog.
Another can be a number limit not to exceed.

Other dialogs can be ones that give the user a choice of on or off or a list of mutually-
exculsive options, like a group of checkboxes. There can also be a dialog that sets a
scale represented by a row of '*' or other characters. One key can move the scale to
the right (increase the value) or to the left (decrease). There will also be a dialog
to set the current time or the time value for something else.

The normal display will show the real-time values like engine rpm, mph, engine temp and
oil pressure. Later on, there can be different displays that show more or less real-time
parameters that can be changed by the menus. When the menu is active, any RT params on
the screen will continue to be displayed in real-time. They just won't over-write any-
thing on the menu area. So the menu or dialog will consume as little as possible area
at the bottom of the display. When 'Enter' or 'Cancel' is pressed the menu or dialog
will cause the previous menu to appear or the user can either hit the '*' key to make
the menu clear or the 'back' key to go back to the previous menu. 

Special character codes sent by the PIC24:

0xFF->0xF0 - PIC24 is sending a sequence of predetermined bytes that are shifted, scaled or 
			bytes combined to make words and displayed at a list of predetermined 
			row,col locations

Special characters sent by AVR to the PIC24:
0xFF - tells PIC24 to start sending a new predetermined sequence of values followed by param
0xFE -> 0xF0 - tells PIC24 to update a certain param followed by param # and value (1 or 2 bytes)
			the PIC24 can send that param to the TS-5500 if it applies.

bytes sent to represent keypresses
0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

When the PIC24 sends a byte in the range of 0xE0 -> 0xEF that will be interpreted as
a keypress. The dialog will filter this out using a switch statement. The default will
just return whatever was passed in. 

When the PIC24 sends a byte in the range of 0xF0 -> 0xFF that will be interpreted as
a special command to do something like hide the menu or update the display RT values.

The dispSetCursor function will set whatever row,col to a blinking cursor but
the dispCharAt function will display the char passed to it at its row,col parameters
regardless of where the blinking cursor is. When the a number is entered at the cursor
and/or the cursor is moved, the main loop will have to restore the current row,col used
by the RT display.

When the PIC24 sends a keypress it will reset the ESOS delay used by the task that is currently
sending data using the 0xFE command so that there won't be any overlapping of data. It can
also use semaphores to wait till the current sequence is finished before sending a keypress.

So the number enter dialog will use the '#' and the 'D' keys to move the cursor left or
right (resp). The any number key pressed will put the number in the space where the cursor
is. The current row,col used by the dialog is stored in the global variable cur_row, cur_col
and the number is in cur_global_number[10]. The dialog updates what's in new_global_number
and if the user cancels out, the new_global_number is reset. If the user hits 'Enter', the
cur_global_number is updated with new_global_number providing the new number is within
limits. 

Screen Layout:

rt_main is an array of RT_MAIN with 5 elements which represents the 5 different types of
screen formats. rt_layout is an array for each rt_main which has the positions and labels
of each param displayed on the screen. The PIC24 will send an 0xFE followed by however
many elements (num_params) are in rt_layout (up to 10). 

typedef struct RT_layout
{
	UCHAR row;
	UCHAR col;
	int label_list;
	int offset;
} RT_LAYOUT_STRUCT;

typedef struct RT_main
{
	char name[10];
	int num_params;
	RT_LAYOUT_STRUCT *ptr_rt_layout;
} RT_MAIN;

RT_MAIN rt_main[no_layouts];

eeprom_burn.c will record the initial 5 different types of screen layouts to eeprom and then
later on we can add a dialog which lets the user change the screen layout to suit.
RT_LAYOUT_STRUCT in RT_MAIN should be a pointer to a malloc'd list of RT_LAYOUT_STRUCT's.
num_params will be the number of params used. A function called update_layouts will fill the
ram space with all the RT_MAIN layouts and then all the RT_LAYOUT_STRUCT's. Then this function
will record it all to eeprom with the no_layouts next to no_prompts and prompt_info_offset at
0x03f4 in eeprom. (no_prompts is at 0x03f0 (byte) and prompt_info_offset is at 0x03f2 (word).

Special chars sent by PIC24 starting with 0xFE: 

0xFF - RT_RPM	- should be a uint16_t	(2 or 3x a second)
0xFE - RT_MPH	- can be a uint8_t		(1x per second)
0xFD - RT_ENGT	- ENGINE TEMP uint8_t			"
0xFC - RT_OILP  - OIL PRESS uint8_t				"
0xFB - RT_OILT	- OIL TEMP uint8_t				"
0xFA - RT_MAP	- MAP, O2, AIR TEMP uint8_t		"
0xF9 - RT_TRIP	- TRIP uint16_t
0xF8 - RT_HIGH0 - set msb of byte (UCHAR sent)
0xF7 - RT_HIGH1	- set msb of low byte set (UINT sent)
0xF6 - RT_HIGH2 - set msb of low byte set (UINT sent)
0xF5 -> 0xF0	- (reserved for future)

The problem is what to do if a keypad code is sent in the middle of a RT sequence:

The routine that parses the sequence data will increment a global counter. If the counter
is not finished when a keypad char is sent, the counter is reset and the sequence data is
ignored and then the keypad function will process the keypress.

The beginning of the sequence is always one of the special characters. The function that
parses the sequence is a state machine that parses the bytes sent and formats param_string
with either xbyte or xword. Currently the only words sent are if the special char is
a RT_RPM. If the byte sent just after the special char is RT_HIGH0/1/2 then set the high
bits for either the byte or word sent. 

menus:

The menus are managed by function pointers. The default menu is main_menu_func. If the '*'
key is pressed the context will return to the previous menu. (the only exception to this
is the main menu).


UCHAR (*fptr[NUM_FPTS])(UCHAR, uint8_t, uint16_t, UCHAR, UCHAR) = { main_menu_func,\
	 menu1a, menu1b,\
	 menu1c, menu1d,\
	 menu2a, menu2b,\
	 menu2c, menu2d, \
	 number_entry };


main_menu_func:
1) menu1a
	1) (go back)
	2) menu2a
	3) menu2b
	4) menu2c
2) menu1b
	1) main_menu_func (go back to top menu for now)
	2)	"    "    "                 "
	3)	"    "    "                 "
	4)	"    "    "                 "
3) menu1c
	1)	"    "    "                 "
	2)	"    "    "                 "
	3)	"    "    "                 "
	4)	"    "    "                 "
4) menu1d
	1)	"    "    "                 "
	2)	"    "    "                 "
	3)	"    "    "                 "
	4)	"    "    "                 "

menu2a:	
	1) number_entry
	2) main_menu_func (go back to top menu for now)
	3)	"    "    "                 "
	4)	"    "    "                 "
	
num_entry:
	enter keypad digits 0->9 - puts number in buffer
	A,B - enter, cancel
	(should present user with final number before enter

alpha_entry:
	enter alphanumeric 0x21->0x7e using a pull-down that lets user scroll thru list
	(or enter 0->9 and/or A->D)
	


params in TS-5500 that can be set:
	tasks: enable,delay,priority
	comm port settings
	change passcode
	Qtraffic: record to logfile, view errors only, etc
		Qtraffic: 
			int type;
			int error;
			UCHAR param;
			UCHAR onoff;
			INT32U OSTime;
			
			
	blinker time
	number of blinks
	rt params:
		engine temp warning
		engine temp shutdown
		oil pressure warning
		oil pressure shutdown
		battery temp on (for battery heater)
		battery temp off	"	"	"
		
checkbox group dialog:
	predefines set of on/off params to change where user can scroll cursor
	to checkboxes and set/unset

dialog for viewing TS-5500 Qtraffic logfiles
	view latest
	view range (date/time)
	reset/erase
	manage files on flash disk
				

