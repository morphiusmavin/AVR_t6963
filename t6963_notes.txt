t6963_notes.txt

******************************************* overview ****************************************

The AVR is just a driver for the LCD display. The serial port of the AVR communicates with a PIC24.
The PIC24 sends a stream of data specified by an array of structs rt_params.

(main.h)
typedef struct rt_params
{
	UCHAR row;			// row, col tells where the param will appear on screen
	UCHAR col;
	UCHAR shown;		// if its shown or not
	UCHAR dtype;		// 0 = UCHAR; 1 = UINT; 2 = dword?
	UCHAR type;			// rt_types
} RT_PARAM;

A 4x4 keypad is attached to the PIC24 so when a key is pressed, one of the 
following bytes is sent to the AVR

0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

When the PIC24 sends a byte in the range of 0xE0 -> 0xEF that will be interpreted as
a keypress. The dialog will filter this out using a switch statement. The default will
just return whatever was passed in. (see get_key() in menus.c)

The array of rt_params is filled in with the function update_rtparams() in eeprom_burn.c
The program compiled in the eeprom directory is used to burn the eeprom initially.
The program compiled in the test_write_data directory is compiled to run on a linux box
and is used to simulate the PIC24 talking to the AVR. So eeprom_burn.c is linked into
both the main program in the parent directory and the simulator in test_write_data.
The section of code at the beginning of main.c reads from the eeprom 3 different arrays:
1) labels
2) rt_params
3) menu_structs
It also reads how many labels, rt_params and menu structs and their offsets into the eeprom.
(see read_eeprom() function in eeprom_burn.c)

Special character codes sent by the PIC24:

RT_RPM
RT_ENGT
RT_TRIP
RT_TIME
RT_AIRT
RT_MPH
RT_OILP
RT_MAP
RT_OILT
RT_O2
RT_AUX1
RT_AUX2

When the PIC24 is sending data to the AVR, each data is preceded by a one of the following:
- RT_LOW	- a UCHAR (unsigned char) is sent without the MSB set (0 -> 0x7F)
- RT_HIGH0	- a UCHAR is sent with the MSB set (0xFF -> 0x80)
- RT_HIGH1	- a UINT (actually a UCHAR) is sent to make up an unsigned int with neither MSB set
- RT_HIGH2	- bit 7 of unsigned int is set
- RT_HIGH3	- bit 15 of unsigned int is set
The state table in parse_P24.c parses the data stream into UINTs and UCHARs and puts them
in param_string in do_read() (when used in the simulator) or in main.c where it calls parse_P24().
Using this scheme allows the AVR to separate the RT_XXX commands from actual data.

*************************************** details ****************************************

The beginning of eeprom stores all the labels used. Another table directly after the labels
stores the offsets from the beginning of eeprom to each label. Any part of the code that uses
the labels can just read them from eeprom as reading doesn't wear out the eeprom like writing
does. Reading out of eeprom is slower than reading from flash which is slower than ram, but
the code doesn't read the labels that often. 

Right after the above tables in eeprom there is an array of rt_params structs. 
typedef struct rt_params
{
	UINT label_offset;	// offset from beginning of eeprom
	UCHAR row;			// row, col tells where the param will appear on screen
	UCHAR col;	
	UCHAR shown;		// if its shown or not
	UCHAR type;			// rt_types
} RT_PARAM;

The array of RT_PARAMS is read into an array in ram and can be changed by commands from
the PIC24 to re-arrange the display.

The next section of eeprom stores the default menu setup which is an array of the MENU_STRUCT:
typedef struct rt_params
{
	UCHAR row;			// row, col tells where the param will appear on screen
	UCHAR col;
	UCHAR shown;		// if its shown or not
	UCHAR dtype;		// 0 = UCHAR; 1 = UINT; 2 = dword?
	UCHAR type;			// rt_types
} RT_PARAM;

This array will be read into program memory on startup and can be changed (added to ?) by
commands from the PIC24.
	
test_write_data:
The subdirectory called test_write_data has a separate makefile that compiles a program that I used
to test some of the functionality so I didn't have to keep reflashing the AVR. I used 2 linux boxes
connected with a crossed over serial cable. The makefile will compile the test_write_data.c
using menus.c, t6963.c, parse_P24 and USART.c from the main directory, the run copy.sh which will
tar up the files needed to compile the program on the other machines. You will have to edit the
copy.sh script to match your machine IP addresses. Then run the extract.sh script on your other
2 machines (I use ssh to run the other 2 machines on my main box).
Then run:
sudo ./test_write r (for the machine that simulates the the AVR) 
and
sudo ./test_write w <interations*10> <starting rpm value> <other 
starting values> <time delay> to simulate the PIC24 or whatever processor is writing the data 
to the AVR.

PIC24 sends commands that modify the RT_PARAM and MENU_FUNC_STRUCT array to display 
params in different format on screen. It will also send commands to tell AVR to only
display certain params. 
For instance. we may only want to see RPM, MPH and engine temp when a non-trivial dialog 
is on the screen. It can also send commands to modify a certain dialog, like different 
labels for checkboxes.

Each menu function that is pointed to by the array of function pointers 

keypad layout - since the six reassignable keys are on the outside (bottom and left) it makes
sense to use these as special function keys.
1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

First load from the eeprom the list of MENU_FUNC_STRUCT's which are in groups of 6 (6 possible
redefined keys for each menu choice) into an array. The 6 redefinable keys are
'A'
'B'
'C'
'D'
'#'
'0'
If the keypress has been reassigned, the 'enabled' field is set. That means the function for
the fptr (index into the list of function pointers) will be called. If the fptr is 0, then 
look up the menu specified by the menu element and just go to that menu. The function assigned 
to '*' in generic_menu_function() will always go back to the previous menu. 

This way, we have 3 possible choices:
1) Use the 'factory default' set of menus in eeprom.
2) Dynamically load another set of menus using a special command from the PIC24.
3) #2 plus burn the new menu set into eeprom.

TODO:

The numentry/alnum dialog should primarily be used for entering a passcode to start the engine.
The AVR code will handle the password retries and timeouts. e.g. three tries to enter passcode and
passcode must be entered within 15 seconds or the system locks out totally for 1/2 hour.

Other parameters to have the system offer the user to change:
	- max rpm before rev-limiter kicks in (turn off ignition momentarily and flash warning light).
	- engine temperature too high and oil pressure too low level warning signals (lights and buzzer).
	- set outdoor temp at which block heater comes on. (when plugged into 110vac outlet)
	- set time of day and length of time other heaters come on.
	- set frequency of blinkers and how long to stay blinking (if not using the conventional switch)
	- how long for headlights to stay on after vehicle shuts off.

? do we really need label_offset[]
if scale_display is called to reduce the display to just rpm, mph, eng temp & oil press then
the PIC24 should not send those values

checkboxes:

The checkboxes are loaded using the RT_AUX state machine:
	- a menu choice sends a command to the AVR state machine that tells the PIC24
		to send either a UCHAR or UINT to modify or a list of binary values that
		will be listed in the checkboxes
	- the list of checkboxes will fill an array of structs: checkboxes[NUM_CHECKBOXES]
	- the list will be displayed on the screen and the user will have the choice
		of scrolling threw the list (blinking cursor is moved), checking/unchecking
		the choice and entering the changes
	- the AVR state machine will tell the PIC24 state machine that the list is ready
		to be sent back to the PIC24

typedef struct checkboxes
{
	UCHAR index;
	UCHAR checked;
	char string[20];
} CHECKBOXES;
	
The array of structs will just be enough to display on the screen (or there could be more if
the scrolling function can move the choices in and out)

menu choices for checkboxes:
A - up
B - down
C - set/clear
D - enter

when using the simulation (test_write_data) the data is sent in aux_data AUX_DATA_SIZE
bytes at a time because of the fact that the serial port is set to non-blocking, there's
a problem sending a variable number of bytes at a time so when it comes time to use it
on the actual hardware, some things may have to be changed...

RT_AUX1 & RT_AUX2 are states that send data back to PIC24. There is a state machine
in RT_AUX1 for both ends. 2 local variable: auxcmd and auxparam get stuffed into the
data (being transmitted with the other RT values) and sent to the AVR and is used to
advance threw the states. The auxcmd/params used by the PIC24 are sent with the 
aux_data values. The reason the PIC24 must send the auxcmd/params in the RT_AUX1 data
stream is so it can be filtered threw the routine that makes sure there's no highbits
set. The AVR can send back as much data (only tested up to 20 bytes) to the PIC24
because there's no filtering going the other way, so it stuffs the auxcmd/params into
the data sent back. There's also an RT_AUX2 data value which acts just like RT_AUX1,
but I don't know if I'll need it yet. The reason for all this trouble is so the keypad
user can set different system values using the keypad,LCD and the menuing system.

When either the start_numentry or the init_checkboxes function is called, the AVR will
send a command to the PIC24 telling it to go get the data. The PIC24 will then send a
command back saying it has the data in aux_data. The user can then modify the data and
then send a command back saying the data has been modified.

This would mean the state machine doesn't start until a dialog is pulled up. This may
not be the best solution if there's other events that occur like a system fault from
the PIC24 that needs to pop-up on the screen (e.g. low wiper fluid level).

1) AVR sends DATA_REQ state in 1st byte of aux_data.
2) When PIC24 has data, it sends back the command VALID_DATA to AVR with aux_data
3) After data is modified, AVR sends a command back: DATA_READY.

keypad layout:

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

