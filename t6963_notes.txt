t6963_notes.txt

keypad layout:

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

Special character codes sent by the PIC24:

0xF5->0xFF - PIC24 is sending a sequence of predetermined bytes that are shifted, scaled or 
			bytes combined to make words and displayed at a list of predetermined 
			row,col locations
	RT_AUX		0xF5	- tells AVR to send a string of 20 bytes that was entered using the numentry/alnum dialog
	RT_TRIP		0xF6	- tells the AVR to expect 1 byte to be sent preceded by either RT_LOW or RT_HIGH0
	RT_TIME,	0xF7	-  "																		"
	RT_AIRT,	0xF8	-  "																		"
	RT_O2,		0xF9	-  "																		"
	RT_MAP,		0xFA	-  "																		"
	RT_OILT,	0xFB	-  "																		"
	RT_OILP,	0xFC	-  "																		"
	RT_ENGT,	0xFD	-  "																		"
	RT_MPH,		0xFE	-  "																		"
	RT_RPM		0xFF	- tells the AVR to expect 2 bytes to be send preceded by either RT_HIGH1/2/3
						- RT_HIGH1 - 2 bytes make up an unsigned int with neither MSB set
						- RT_HIGH2 - bit 7 of unsigned int is set
						- RT_HIGH3 - bit 15 of unsigned int is set

using this scheme allows the AVR to separate the RT_XXX commands from actual data						

bytes sent to represent keypresses
0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

When the PIC24 sends a byte in the range of 0xE0 -> 0xEF that will be interpreted as
a keypress. The dialog will filter this out using a switch statement. The default will
just return whatever was passed in. 

When the PIC24 sends a byte in the range of 0xF0 -> 0xFF that will be interpreted as
a special command to do something like hide the menu or update the display RT values.

typedef struct prompts
{
	uint8_t pnum;
	UCHAR row;
	UCHAR col;
    uint16_t offset;
	int len;
    uint8_t type;
} PROMPT_STRUCT;

eeprom_burn.c will record the initial 5 different types of screen layouts to eeprom and then
later on we can add a dialog which lets the user change the screen layout to suit.
RT_LAYOUT_STRUCT in RT_MAIN should be a pointer to a malloc'd list of RT_LAYOUT_STRUCT's.
num_params will be the number of params used. A function called update_layouts will fill the
ram space with all the RT_MAIN layouts and then all the RT_LAYOUT_STRUCT's. Then this function
will record it all to eeprom with the no_layouts next to no_prompts and prompt_info_offset at
0x03f4 in eeprom. (no_prompts is at 0x03f0 (byte) and prompt_info_offset is at 0x03f2 (word).

Special chars sent by PIC24:

The PIC24 sends a sequence of chars starting with one of the RT_TYPES. Each RT_TYPE is followed
by a DATA_TYPE which tells the AVR what kind of data to expect. All the data is sent as UCHAR
except for RT_RPM which is a UINT. If the data sent as a UCHAR is < 0x7f (127) the data type
will be RT_LOW. If the high bit is set (> 0x7f) the data type will be RT_HIGH0. If a UINT is 
set without the high bit for the first or second byte the data type will be RT_HIGH1. RT_HIGH2
has bit 7 set and RT_HIGH3 has bit 15 set. The AVR will then know by the data type sent just
after the RT_TYPE how to format the data (adding the appropriate high bit back in before printing
it to the screen. The reason for this is so it can filter out the keypresses (0xE0->0xEF).


test_write_data:
The subdirectory call test_write_data has a separate makefile that compiles a program that I used
to test some of the functionality so I didn't have to keep reflashing the AVR. I used 2 linux boxes
connected with a crossed over serial cable. Run make, which will compile the test_write_data.c
using menus.c, t6963.c and USART.c from the main directory, the run copy.sh which will tar up the
files needed to compile the program on the other machines. You will have to edit the copy.sh script
to match your machine IP addresses. Then run the extract.sh script on your other 2 machines (I use
ssh to run the other 2 machines on my main box) and then run sudo ./test_write (for the machine that
simulates the the AVR) and sudo ./test_write <interations*10> <starting rpm value> <other starting
values> <time delay> to simulate the PIC24 or whatever processor is writing the data to the AVR.

TODO:

PIC24 sends commands that modify the menu_struct array to display params in different format on screen.
It will also send commands to tell AVR to only display certain params. For instance. we may only 
want to see RPM, MPH and engine temp when a non-trivial dialog is on the screen. It can also send
commands to modify a certain dialog, like different labels for checkboxes.

The prompt struct can have fields that define the what keypad keys are assigned to the current
menu function. And also the placement on the screen that applies to that menu.

There can be a field that only applies to the rt types, like RT_RPM that tells the AVR to read it
as a UINT or a UCHAR (or string?).

The numentry/alnum dialog should primarily be used for entering a passcode to start the engine.
The AVR code will handle the password retries and timeouts. e.g. three tries to enter passcode and
passcode must be entered within 15 seconds or the system locks out totally for 1/2 hour.

Other parameters to have the system offer the user to change:
	- max rpm before rev-limiter kicks in (turn off ignition momentarily and flash warning light).
	- engine temperature too high and oil pressure too low level warning signals (lights and buzzer).
	- set outdoor temp at which block heater comes on. (when plugged into 110vac outlet)
	- set time of day and length of time other heaters come on.
	- set frequency of blinkers and how long to stay blinking (if not using the conventional switch)
	- how long for headlights to stay on after vehicle shuts off.
	
The new menu format can be loaded onto the flash disk in the TS-7200 (after turning if off) and then
when its powered back up it can coordinate with the PIC24 and the AVR to load the new menu format
and burn it to eeprom since there's not enough room in ram to hold the whole array of menu_struct.
The AVR has to read it from eeprom every time it changes to a different menu.
