t6963_notes.txt

keypad layout:

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

Special character codes sent by the PIC24:

0xF5->0xFF - PIC24 is sending a sequence of predetermined bytes that are shifted, scaled or 
			bytes combined to make words and displayed at a list of predetermined 
			row,col locations
	RT_AUX		0xF5	- tells AVR to send a string of 20 bytes that was entered using the numentry/alnum dialog
	RT_TRIP		0xF6	- tells the AVR to expect 1 byte to be sent preceded by either RT_LOW or RT_HIGH0
	RT_TIME,	0xF7	-  "																		"
	RT_AIRT,	0xF8	-  "																		"
	RT_O2,		0xF9	-  "																		"
	RT_MAP,		0xFA	-  "																		"
	RT_OILT,	0xFB	-  "																		"
	RT_OILP,	0xFC	-  "																		"
	RT_ENGT,	0xFD	-  "																		"
	RT_MPH,		0xFE	-  "																		"
	RT_RPM		0xFF	- tells the AVR to expect 2 bytes to be send preceded by either RT_HIGH1/2/3
						- RT_HIGH1 - 2 bytes make up an unsigned int with neither MSB set
						- RT_HIGH2 - bit 7 of unsigned int is set
						- RT_HIGH3 - bit 15 of unsigned int is set

using this scheme allows the AVR to separate the RT_XXX commands from actual data						

bytes sent to represent keypresses
0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

When the PIC24 sends a byte in the range of 0xE0 -> 0xEF that will be interpreted as
a keypress. The dialog will filter this out using a switch statement. The default will
just return whatever was passed in. 

The beginning of eeprom stores all the labels used. Another table directly after the labels
stores the offsets from the beginning of eeprom to each label. Any part of the code that uses
the labels can just read them from eeprom as reading doesn't wear out the eeprom like writing
does. Reading out of eeprom is slower than reading from flash which is slower than ram, but
the code doesn't read the labels that often. 

Right after the above tables in eeprom there is an array of rt_params structs. 
typedef struct rt_params
{
	UINT label_offset;	// offset from beginning of eeprom
	UCHAR row;			// row, col tells where the param will appear on screen
	UCHAR col;	
	UCHAR shown;		// if its shown or not
	UCHAR type;			// 0 - UCHAR; 1 - UINT; 2 - string
} RT_PARAM;

The array of RT_PARAMS is read into an array in ram and can be changed by commands from
the PIC24 to re-arrange the display.

The next section of eeprom stores the default menu setup which is an array of the MENU_STRUCT:
typedef menu_struct
{
	UCHAR pnum;			// index
	UINT label_offset;	// offset into label section of eeprom of which label to use
	UCHAR row,			// row, col where the label will be displayed
	UCHAR col;
	UCHAR menu_choice;	// the type of keypress in the switch statement of the menu
	UCHAR type;			// index of which function pointer this menu label is associated with
} MENU_STRUCT;

This array will be read into program memory on startup and can be changed (added to ?) by
commands from the PIC24.
	
test_write_data:
The subdirectory call test_write_data has a separate makefile that compiles a program that I used
to test some of the functionality so I didn't have to keep reflashing the AVR. I used 2 linux boxes
connected with a crossed over serial cable. Run make, which will compile the test_write_data.c
using menus.c, t6963.c and USART.c from the main directory, the run copy.sh which will tar up the
files needed to compile the program on the other machines. You will have to edit the copy.sh script
to match your machine IP addresses. Then run the extract.sh script on your other 2 machines (I use
ssh to run the other 2 machines on my main box) and then run sudo ./test_write r (for the machine 
that simulates the the AVR) and sudo ./test_write w <interations*10> <starting rpm value> <other 
starting values> <time delay> to simulate the PIC24 or whatever processor is writing the data 
to the AVR.

TODO:

PIC24 sends commands that modify the RT_PARAM and MENU_STRUCT array to display params in different 
format on screen. It will also send commands to tell AVR to only display certain params. 
For instance. we may only want to see RPM, MPH and engine temp when a non-trivial dialog 
is on the screen. It can also send commands to modify a certain dialog, like different 
labels for checkboxes.

Each menu function that is pointed to by the array of function pointers 

The numentry/alnum dialog should primarily be used for entering a passcode to start the engine.
The AVR code will handle the password retries and timeouts. e.g. three tries to enter passcode and
passcode must be entered within 15 seconds or the system locks out totally for 1/2 hour.

Other parameters to have the system offer the user to change:
	- max rpm before rev-limiter kicks in (turn off ignition momentarily and flash warning light).
	- engine temperature too high and oil pressure too low level warning signals (lights and buzzer).
	- set outdoor temp at which block heater comes on. (when plugged into 110vac outlet)
	- set time of day and length of time other heaters come on.
	- set frequency of blinkers and how long to stay blinking (if not using the conventional switch)
	- how long for headlights to stay on after vehicle shuts off.

checkboxes:

menu fptr sends a command to the PIC24 to tell it to send an array of structs:
- int index
- char *label_str
- UCHAR checked

The index can start anywhere in a huge list of all possible binary settings (on/off). The label describes
the setting and checked tells if it was previously set. All the AVR does is display so many on the list
and use the A/B keys to scroll up and down and the C key to check/uncheck the current checkbox.

last 3 checkins:
61ae87f did total revamp - works in test_data but menus not working yet
1e61ba3 separated do_read function into do_read.c
7e1a630 added scripts to remove trailing whitespace


